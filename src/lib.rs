#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

include!(concat!(env!("OUT_DIR"), "/bindings.rs"));

use std::io::{
    Error,
    ErrorKind
};

/// Function to verify the signature of given data using a given public key
/// The signature is expected to be a 64 byte long vector
/// If the check is successfull, the function returns Ok(())
/// Otherwise it returns an Error of type std::io::Error
pub fn verify_signature_ed25519(data: &Vec<u8>, signature: &Vec<u8>, public_key: &Vec<u8>) -> Result<(), Error> {
    unsafe{ 
        if crypto_ed25519_check(
            signature.as_ptr() as *const u8, 
            public_key.as_ptr() as *const u8,
            data.as_ptr() as *const u8,
            data.len()) 
            == 0 {
            return Ok(())
        }
    };
    return Err(Error::new(ErrorKind::InvalidData, "Signature was wrong"))
}

/// Function to sign the given data using the given private key
/// The private key is expected to be a 32 byte long vector
/// The function returns a 64 byte long vector containing the signature
pub fn sign_ed25519(data: &Vec<u8>, private_key: &Vec<u8>) -> Result<Vec<u8>, Error> {
    let mut signature = vec![0; 64];
    unsafe { crypto_ed25519_sign(
        signature.as_mut_ptr() as *mut u8, 
        private_key.as_ptr(), 
        data.as_ptr(), 
        data.len()) };
    Ok(signature)
}

/// Hashes the given data using the blake2b algorithm with a 512 bit output size
pub fn blake2b_512(data: &Vec<u8>) -> Result<Vec<u8>, Error>{
    blake2b(data, 64)
}

/// Hashes the given data using the blake2b algorithm with a 256 but output size
pub fn blake2b_256(data: &Vec<u8>) -> Result<Vec<u8>, Error>{
    blake2b(data, 32)
}

/// Hashes the given data using the blake2b algorithm
fn blake2b(data: &Vec<u8>, hash_size: usize) -> Result<Vec<u8>, Error>{
    let mut result = vec![0; hash_size];
    unsafe { crypto_blake2b(result.as_mut_ptr() as *mut u8, 
        hash_size, 
        data.as_ptr(), 
        data.len()) };
    Ok(result.to_vec())
}

pub fn chacha20_poly1305_encrypt(data: &Vec<u8>, additional_data: &Vec<u8>, key: &[u8; 32], nonce: &[u8; 24]) -> Result<(Vec<u8>, [u8; 16]), Error> {
    let mut ciphertext = vec![0; data.len()];
    let mut mac: [u8; 16] = [0; 16];
    unsafe{ crypto_aead_lock(ciphertext.as_mut_ptr() as *mut u8, 
        mac.as_mut_ptr() as *mut u8, 
        key.as_ptr(), 
        nonce.as_ptr(), 
        additional_data.as_ptr(), 
        additional_data.len(), 
        data.as_ptr(), 
        data.len()) };
    Ok((ciphertext, mac))
}

pub fn chacha20_poly1305_decrypt(ciphertext: &Vec<u8>, additional_data: &Vec<u8>, mac: &[u8; 16],key: &[u8; 32], nonce: &[u8; 24]) -> Result<Vec<u8>, Error> {
    let mut plaintext = vec![0; ciphertext.len()];
    let result = unsafe{ crypto_aead_unlock(plaintext.as_mut_ptr() as *mut u8, 
        mac.as_ptr() as *const u8, 
        key.as_ptr(), 
        nonce.as_ptr(), 
        additional_data.as_ptr(), 
        additional_data.len(), 
        ciphertext.as_ptr(), 
        ciphertext.len()) };
    if result == 0 {
        Ok(plaintext)
    } else {
        Err(Error::new(ErrorKind::InvalidData, "Decryption failed"))
    }
}

pub fn chacha20_poly1305_ietf_encrypt(data: &Vec<u8>, additional_data: &Vec<u8>, key: &[u8; 32], nonce: &[u8; 12]) -> Result<(Vec<u8>, [u8; 16]), Error> {
    let mut ciphertext = vec![0; data.len()];
    let mut mac: [u8; 16] = [0; 16];
    unsafe{ crypto_aead_ietf_lock(ciphertext.as_mut_ptr() as *mut u8,
        mac.as_mut_ptr() as *mut u8,
        key.as_ptr(),
        nonce.as_ptr(),
        additional_data.as_ptr(),
        additional_data.len(),
        data.as_ptr(),
        data.len())};
    Ok((ciphertext, mac))
}

pub fn chacha20_poly1305_ietf_decrypt(ciphertext: &Vec<u8>, additional_data: &Vec<u8>, mac: &[u8; 16], key: &[u8; 32], nonce: &[u8; 12]) -> Result<Vec<u8>, Error> {
    let mut plaintext = vec![0; ciphertext.len()];
    let result = unsafe{ crypto_aead_ietf_unlock(plaintext.as_mut_ptr() as *mut u8, 
        mac.as_ptr() as *const u8, 
        key.as_ptr(), 
        nonce.as_ptr(),
        additional_data.as_ptr(),
        additional_data.len(), 
        ciphertext.as_ptr(), 
        ciphertext.len()) };
    if result == 0 {
        Ok(plaintext)
    } else {
        Err(Error::new(ErrorKind::InvalidData, "Decryption failed"))
    }
}

mod test_monocypher_binding{
    // Imports only necessary for test module, dead code because of helper function
    #![allow(unused_imports)]
    #![allow(dead_code)]
    use super::*;
    use std::{
        fs,
        env
    };
    
    #[test]
    fn test_verify_signature_ed25519(){
        let data = vec![0x10, 0x20, 0x30, 0x40];
        let signature = vec![0x72,0x43,0x8f,0x03,0x5d,0x07,0xa1,0x0c,0x10,0x38,0xf5,0x1c,0xdd,0x31,0x66,0xb9,0x0b,0x37,0x54,0x5a,0xcc,0x34,0x6c,0x82,0xdd,0x7c,0xbe,0xbb,0xe6,0xd8,0x11,0x71,0x9e,0xb6,0x65,0xee,0xf2,0xfa,0x04,0x04,0xbe,0xa5,0x20,0xe3,0xbb,0x7d,0x87,0x18,0x16,0xba,0xc9,0x51,0x3e,0x47,0xbf,0x33,0xda,0x20,0x15,0xd3,0x6c,0xfe,0x55,0x09];        
        let key: Vec<u8> = vec![0x79,0x12,0xf9,0xf5,0xc6,0x82,0x0b,0x4c,0x00,0x99,0xb5,0x92,0x6c,0xb0,0xb0,0x0b,0x20,0x67,0xc1,0xda,0x3c,0xa1,0x45,0x89,0x81,0xdc,0x69,0xc8,0x39,0xb8,0xae,0xa5];
        let result = verify_signature_ed25519(&data, &signature, &key);
        assert!(result.is_ok());
    }

    #[test]
    fn test_verify_signature_ed25519_fail(){
        let data = vec![0x20, 0x30, 0x40, 0x50];
        let signature = vec![0x72,0x43,0x8f,0x03,0x5d,0x07,0xa1,0x0c,0x10,0x38,0xf5,0x1c,0xdd,0x31,0x66,0xb9,0x0b,0x37,0x54,0x5a,0xcc,0x34,0x6c,0x82,0xdd,0x7c,0xbe,0xbb,0xe6,0xd8,0x11,0x71,0x9e,0xb6,0x65,0xee,0xf2,0xfa,0x04,0x04,0xbe,0xa5,0x20,0xe3,0xbb,0x7d,0x87,0x18,0x16,0xba,0xc9,0x51,0x3e,0x47,0xbf,0x33,0xda,0x20,0x15,0xd3,0x6c,0xfe,0x55,0x09];        
        let key: Vec<u8> = vec![0x79,0x12,0xf9,0xf5,0xc6,0x82,0x0b,0x4c,0x00,0x99,0xb5,0x92,0x6c,0xb0,0xb0,0x0b,0x20,0x67,0xc1,0xda,0x3c,0xa1,0x45,0x89,0x81,0xdc,0x69,0xc8,0x39,0xb8,0xae,0xa5];
        let result = verify_signature_ed25519(&data, &signature, &key);
        assert!(result.is_err());
    }

    /// Test the sign and verify functions using the test vectors from the sign.input file
    /// The file is originating from https://ed25519.cr.yp.to/python/sign.input and
    /// is referenced in RFC8032
    #[test]
    fn test_sign_and_verify_from_file() {

        // Read the sign.input file
        let file_content = fs::read_to_string(format!("{}/src/test_sign.input", env::var("CARGO_MANIFEST_DIR").unwrap())).expect("Failed to read sign.input file");
        let lines: Vec<&str> = file_content.lines().collect();
        let mut counter = 0;
        // Iterate over each line in the file
        for line in lines {
            // Split the line into private_key, public_key, message, and expected_signature
            let parts: Vec<&str> = line.split(':').collect();
            let private_key = hex_to_bytes(parts[0]).expect("Failed to decode private key");
            let public_key = hex_to_bytes(parts[1]).expect("Failed to decode public key");
            let message = hex_to_bytes(parts[2]).expect("Failed to decode message");
            let expected_signature = hex_to_bytes(parts[3]).expect("Failed to decode expected signature")[..64].to_vec();

            // Sign the message using the private key
            let signature = sign_ed25519(&message, &private_key).expect("Failed to sign message");

            // Verify that the signature matches the expected signature
            assert_eq!(signature, expected_signature);

            // Verify the signature using the public key
            let result = verify_signature_ed25519(&message, &expected_signature, &public_key);
            assert!(result.is_ok());
            counter += 1;
        }
        assert_eq!(counter, 1024);
    }

    // Helper function to mitigate import of "hex" crate
    fn hex_to_bytes(s: &str) -> Option<Vec<u8>> {
        if s.len() % 2 == 0 {
            (0..s.len())
                .step_by(2)
                .map(|i| s.get(i..i + 2)
                          .and_then(|sub| u8::from_str_radix(sub, 16).ok()))
                .collect()
        } else {
            None
        }
    }

    #[test]
    fn test_blake2b(){
        assert_eq!(blake2b_512(&"TEST".as_bytes().to_vec()).unwrap(), vec![0x53,0x22,0xbc,0x39,0xe2,0x00,0xa6,0xd2,0xef,0x54,0xac,0x67,0x16,0x37,0x6d,0x50,0x00,0xf9,0x8a,0x97,0x15,0xcb,0x52,0x93,0xed,0xd6,0xe1,0xe0,0xf8,0x86,0x5d,0x3b,0x22,0xcb,0x0f,0xa9,0x2e,0x09,0xd5,0x2a,0xbe,0xf0,0xcf,0x58,0xa2,0xb0,0x67,0xd4,0xbc,0x64,0xfb,0xee,0x1e,0x4b,0xce,0x0e,0x9e,0x64,0x2c,0xe8,0x03,0xdc,0x6f,0x99])
    }

    #[test]
    fn test_blake2b_256(){
        assert_eq!(blake2b_256(&vec![0xcf,0xcc,0x95,0xee,0x42,0xe9,0x65,0x25,0xc5,0xbf]).unwrap(), 
            vec![0xa3,0xc7,0x12,0xbf,0x4f,0xa1,0xbc,0x88,0x60,0xc1,0x9f,0xaf,0x8e,0x8f,0xde,0xe0,0xdc,0x06,0x54,0x62,0xc7,0x88,0x1a,0x90,0xfa,0x11,0x6f,0x10,0xa7,0x22,0x00,0x4f]);
    }

    #[test]
    fn test_encryption_decryption(){
        let data = vec![0x10, 0x20, 0x30, 0x40];
        let key = [0x79,0x12,0xf9,0xf5,0xc6,0x82,0x0b,0x4c,0x00,0x99,0xb5,0x92,0x6c,0xb0,0xb0,0x0b,0x20,0x67,0xc1,0xda,0x3c,0xa1,0x45,0x89,0x81,0xdc,0x69,0xc8,0x39,0xb8,0xae,0xa5];
        let nonce = [0x51,0xd2,0x1a,0xf7,0x6e,0x3c,0xac,0x6e,0xb7,0x12,0x0a,0xc2,0xa3,0x5f,0x8b,0x93,0xcb,0xec,0x44,0x11,0xe8,0x75,0xb4,0x62];
        let (ciphertext, mac) = chacha20_poly1305_encrypt(&data, &Vec::<u8>::new(), &key, &nonce).unwrap();
        let plaintext = chacha20_poly1305_decrypt(&ciphertext, &Vec::<u8>::new(),  &mac, &key, &nonce).unwrap();
        assert_eq!(data, plaintext);
    }

    #[test]
    fn test_ietf_encryption_decryption(){
        let data = vec![0x10, 0x20, 0x30, 0x40];
        let key = [0x79,0x12,0xf9,0xf5,0xc6,0x82,0x0b,0x4c,0x00,0x99,0xb5,0x92,0x6c,0xb0,0xb0,0x0b,0x20,0x67,0xc1,0xda,0x3c,0xa1,0x45,0x89,0x81,0xdc,0x69,0xc8,0x39,0xb8,0xae,0xa5];
        let nonce = [0x79,0x12,0xf9,0xf5,0xc6,0x82,0x0b,0x4c,0x00,0x99,0xb5,0x92];
        let (ciphertext, mac) = chacha20_poly1305_ietf_encrypt(&data,  &Vec::<u8>::new(), &key, &nonce).unwrap();
        let plaintext = chacha20_poly1305_ietf_decrypt(&ciphertext, &Vec::<u8>::new(), &mac, &key, &nonce).unwrap();
        assert_eq!(data, plaintext);
    }

    /// RFC8493 A.5 test vector
    #[test]
    fn test_ietf_decryption_rfc(){
        let plaintext_string = "Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as /“work in progress./”".to_string();
        let ciphertext: Vec<u8> = vec![0x64,0xa0,0x86,0x15,0x75,0x86,0x1a,0xf4,0x60,0xf0,0x62,0xc7,0x9b,0xe6,0x43,0xbd,0x5e,0x80,0x5c,0xfd,0x34,0x5c,0xf3,0x89,0xf1,0x08,0x67,0x0a,0xc7,0x6c,0x8c,0xb2,0x4c,0x6c,0xfc,0x18,0x75,0x5d,0x43,0xee,0xa0,0x9e,0xe9,0x4e,0x38,0x2d,0x26,0xb0,0xbd,0xb7,0xb7,0x3c,0x32,0x1b,0x01,0x00,0xd4,0xf0,0x3b,0x7f,0x35,0x58,0x94,0xcf,0x33,0x2f,0x83,0x0e,0x71,0x0b,0x97,0xce,0x98,0xc8,0xa8,0x4a,0xbd,0x0b,0x94,0x81,0x14,0xad,0x17,0x6e,0x00,0x8d,0x33,0xbd,0x60,0xf9,0x82,0xb1,0xff,0x37,0xc8,0x55,0x97,0x97,0xa0,0x6e,0xf4,0xf0,0xef,0x61,0xc1,0x86,0x32,0x4e,0x2b,0x35,0x06,0x38,0x36,0x06,0x90,0x7b,0x6a,0x7c,0x02,0xb0,0xf9,0xf6,0x15,0x7b,0x53,0xc8,0x67,0xe4,0xb9,0x16,0x6c,0x76,0x7b,0x80,0x4d,0x46,0xa5,0x9b,0x52,0x16,0xcd,0xe7,0xa4,0xe9,0x90,0x40,0xc5,0xa4,0x04,0x33,0x22,0x5e,0xe2,0x82,0xa1,0xb0,0xa0,0x6c,0x52,0x3e,0xaf,0x45,0x34,0xd7,0xf8,0x3f,0xa1,0x15,0x5b,0x00,0x47,0x71,0x8c,0xbc,0x54,0x6a,0x0d,0x07,0x2b,0x04,0xb3,0x56,0x4e,0xea,0x1b,0x42,0x22,0x73,0xf5,0x48,0x27,0x1a,0x0b,0xb2,0x31,0x60,0x53,0xfa,0x76,0x99,0x19,0x55,0xeb,0xd6,0x31,0x59,0x43,0x4e,0xce,0xbb,0x4e,0x46,0x6d,0xae,0x5a,0x10,0x73,0xa6,0x72,0x76,0x27,0x09,0x7a,0x10,0x49,0xe6,0x17,0xd9,0x1d,0x36,0x10,0x94,0xfa,0x68,0xf0,0xff,0x77,0x98,0x71,0x30,0x30,0x5b,0xea,0xba,0x2e,0xda,0x04,0xdf,0x99,0x7b,0x71,0x4d,0x6c,0x6f,0x2c,0x29,0xa6,0xad,0x5c,0xb4,0x02,0x2b,0x02,0x70,0x9b];
        let key: [u8; 32] = [0x1c,0x92,0x40,0xa5,0xeb,0x55,0xd3,0x8a,0xf3,0x33,0x88,0x86,0x04,0xf6,0xb5,0xf0,0x47,0x39,0x17,0xc1,0x40,0x2b,0x80,0x09,0x9d,0xca,0x5c,0xbc,0x20,0x70,0x75,0xc0];
        let nonce: [u8; 12] = [0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08];
        let additional_data: Vec<u8> = vec![0xf3,0x33,0x88,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x4e,0x91];
        let mac: [u8; 16] =[0xee,0xad,0x9d,0x67,0x89,0x0c,0xbb,0x22,0x39,0x23,0x36,0xfe,0xa1,0x85,0x1f,0x38];
        
        let plaintext = chacha20_poly1305_ietf_decrypt(&ciphertext, &additional_data, &mac, &key, &nonce).unwrap();
        assert_eq!(plaintext_string.as_bytes().to_vec(), plaintext);
        
    }



}